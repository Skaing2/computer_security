/******************************************************************************************
 * Program:
 *    Week 08 LAB, Vulnerability and Exploit
 *    Brother Phillips, CSE-453
 * Author:
 *    Martin Vaughn, Wyatt Nelson,  Lucas Feritas, Fillipe Ferreira, Sedona Tooley, 
 *    Joshua Rolph and Sengthay Kaing
 * Summary:
 *    For this week's assignment, we want to understand and demonstrate seven veulnerbilities
 *    and seven exploits. They are Array Index, ARC Injection, VTable Spraying, Stack
 *    Smashing, Heap Spraying, Integer Overflow, and ANSI-Unicode Conversion. We will 
 *    write each vulnerability with a function of vulnerability, working function to see 
 *    how it works and exploit function to see how it get hacked or attacked.
 * Estimated: 10 hrs
 * Actual: 16 hrs
 *    The most difficult part would be the basic things of C++ such as undestanding 
 *    how to use Class, Stack, Heap, Pointers, and passing parameters with functions well. 
 ********************************************************************************************/

/**********************************************************
* This program allow us to have accesses to the libraries. 
***********************************************************/
#include <iostream>
#include <string>
#include <cassert>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <string.h>
using namespace std;

/************************************************************
* 1. ---------------------Array Index----------------------
 ********************************************************/

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ****************************************/
void arrayVulnerability(long a)
{
  char buffer[10] = {};
  bool access = false;
  buffer[a] = 5;
  if (access == false) {
    cout << "Access: Granted and Safe 😀  😀  😀 " << endl;
  } else {
    cout << "Access: Not Granted and Dangerous 😰  😰  😰 " << endl;
  }
}

/**************************************
 * ARRAY WORKING
 * Call arrayVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void arrayWorking()
{
  // w = working
  long w = 1;
  cout << endl << "The Array Index Working: " << endl << "     ";
  arrayVulnerability(w);
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
  // exp = Exploit
  long exp = -1;
  cout << endl << "The Array Index Exploitation: " << endl << "     ";
  arrayVulnerability(exp);
}

/*****************************************************************
* 2. ----------------------Pointer Subterfuge--------------------
 *****************************************************************/

/****************************************
 * Pointer Subterfuge Vulnerability
 * 1. There must be a pointer used in the code.
 * 2. There must be a way to overwrite the pointer
 * 3. After the pointer is overwritten, the pointer is dereferenced
 ****************************************/
void psVulnerability(long * array, int size) {
  long int buffer[2];
  const char * message = "Safe 😄 😄";
  // long buffer[2];
  for (int i = 0; i < size; i++) {
    buffer[i] = array[i];
  }
  cout << "Message is: \"" << message << "\".\n";
}

/*************************************
 * Pointer Subterfuge WORKING 
 * Call psVulnerability() in a way that does
 * not yield unexpected behavior
 ***********************************/
void psWorking() { 
  long array[2] = {1, 1};
  psVulnerability(array, 1);
}

/****************************************
 * Pointer Subterfuge Exploitation
 * 1. The attacker must exploit a vulnerability allowing
 *    unintended access to the pointer
 * 2. The attacker must be able to provide a new pointer
 *    referring to data altering the normal flow of the program
 ****************************************/
void psExploit() {
  // an attacker’s array
  long int array[3] = {1, 1, (long int)"Dangerous 😑 😑 😑 "};
  psVulnerability(array, 3);
}

/********************************************************************
* 3. --------------------ARC Injection----------------------------
 ***********************************************************************/

/********************************************************************
* This Pass ARC Injection function is for the Pointer Function
 ***********************************************************************/
long int pass_arc() {
  cout << "Passed, everything is safe. 🥰  🥰  🥰" << endl;
  return 0;
}

/********************************************************************
* This Fail ARC Injection Function is for the Exploit Function
 ***********************************************************************/
long int fail_arc() {
  cout << "Dangerous, you are being hacked, sucks to be you... 🥺  🥺  🥺" << endl;
  return 0; 
}

/*********************************
 * ARC VULNERABILITY
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input
 *    to overwrite the function pointer. This typically happens through
 *    a stack buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must
 *    be dereferenced
 ********************************/
void arcVulnerability(long index, long data) {
    long int buffer[2];
    long(* pointer_function)() = pass_arc;
    buffer[index] = data;
    pointer_function();
}

/*************************************
 * ARC WORKING 
 * Call intVulnerability() in a way that does
 * not yield unexpected behavior
 ***********************************/
void arcWorking() {
    cout << endl << "ARC Injection Working is " << endl << "     ";
    arcVulnerability(0, 2);
}

/*********************************
 * ARC EXPLOIT
 * 1. The attacker must exploit a vulnerability allowing
 *    unintended access to the function pointer
 * 2. The attacker must have the address to another function
 *    which is to be used to replace the existing function pointer
  ********************************/
void arcExploit() {
  cout << "ARC Injection Exploit is " << endl << "     ";
  arcVulnerability(-1, (long int)fail_arc);
}

 /*********************************************************************
* 4. -----------------------VTable Spraying--------------------------
 ************************************************************************/

/***********************************
 * VULNERABILITY
 * 1. The vulnerable class must be polymorphic.
 * 2. The class must have a buffer as a member variable.
 * 3. Through some vulnerability, there must be a way for user input
 *    to overwrite parts of the VTable.
 * 4. After a virtual function pointer is overwritten,
 *    the virtual function must be called.
 **********************************/
class Vulnerability 
{
  public:
  long buffer[2];  //buffer as a member variable

  // Vulnerable function
  void setNumber(long value, int index)
  {
      buffer[index] = value; // overwrite parts of the VTable.
  }
  virtual void display() const = 0; // polymorphic function
};

/**********************************************************
*  Creating class Safe Function
***********************************************************/
class Safe : public Vulnerability
{
public:
  virtual void display() const // Calls the virtual function
  {
    std::cout << "     All is safe; nothing bad Happened 😍  😍  😍\n";
  }
};

/**********************************************************
*  This dangerous Function is for the Exploit VTable Function
***********************************************************/
void dangerous()
{
  std::cout << "You've been hacked 😠  😠  😠";
};

/*************************************
 * VTable WORKING 
 * Call Vulnerability() in a way that does
 * not yield unexpected behavior
 ***********************************/
void vtableWorking() {
  std::cout << endl << "Vtable Working: \n";
  Safe s;

  s.setNumber(2, 2);
  s.display();
}

/************************************
 * VTABLE EXPLOIT
 * 1. Through some vulnerability, the VTable pointer
 *     or a function pointer within the VTable must be overwritten
 * 2. The attacker must have the address to another VTable pointer
 *     or a function pointer
 ***********************************/
void vtableExploit() {
  std::cout << "Vtable Exploit\n";
  Safe s;
  void (*pointerFunction)() = dangerous; // provide a pointer
  
  s.setNumber ((long)pointerFunction, -5); // overwirte the pointer
  s.display();
}

 /*********************************************************************
* 5. -------------------------Stack Smashing------------------------
 ***********************************************************************/

/********************************************************************
* This Fail Stack Smashing Function is for the Exploit Function
 ***********************************************************************/
long int fail_stack() {
  cout << "     Dangerous and Malicious.. 😤  😤  😤" << endl;
  return 0; 
}

/***********************************************
 * STACK VULNERABILITY
 * 1. There must be a buffer on the stack
 * 2. the buffer must be reachable from an external input
 * 3. The mechanism to fill the buffer must not check the correct buffersize
 * 4. The buffer must be overrun (extend beyond the
 *    intended limits for the array).
 **********************************************/
void stackVulnerability(long index, long data) {
  long int buffer[2];
  buffer[index] = data;
}

/*************************************
 * Stack Smashing WORKING 
 * Call stackVulnerability() in a way that does
 * not yield unexpected behavior
 ***********************************/
void stackWorking() {
  cout << endl;
  cout << "Stack Working: " << endl;
  cout << "     Safe and None-Malicious 😜  😜  😜" << endl;
  // long points[4] = {1, 2, 3, 4};
  stackVulnerability(1, 4);
}

/*********************************************
 * STACK EXPLOIT
 * 1. The attacker must provide more data into the
 *    outwardly facing buffer than the buffer is designed to hold
 * 2. The attacker must know where the the stack pointer resides
 *    on the stack. This should be just beyond the end of the buffer
 * 3. The attacker must insert machine language instructions in the buffer.
 *    This may occur before, after, or even around the stack pointer. The
 *    machine language could be already compiled code in the program
 * 4. The attacker must overwrite the stack pointer. The old value,
 *    directing the flow of the program after the function is returned,
 *    must be changed from the calling function to the provided
 *    machine language in step 3.
 *********************************************/
void stackExploit() {
  cout << endl << "Stack Exploitation: " << endl;
  stackVulnerability(5, (long int) &fail_stack);
  cout << "This Code should never run.";
}

 /**************************************************************
* 6. -----------------------Heap Spraying----------------------
 ***********************************************************/

/*************************************
 * HEAP VULNERABILITY
 * 1. There must be two adjacent heap buffers.
 * 2. The first buffer must be reachable through external input.
 * 3. The mechanism to fill the buffer from the external input must
 *    not correctly check for the buffer size.
 * 4. The second buffer must be released before the first.
 *************************************/
void heapVulnerability(char *input, int d) {
    char * bufferOne = new char[4];
    char * bufferTwo = new char[4];
    // The first buffer must be reachable through external input.
    assert(bufferOne < bufferTwo);
    for (int i = 0; i < d; i++) {
      bufferOne[i] = input[i];
    }
    delete [] bufferTwo; // free second buffer before the first one
    delete [] bufferOne;
}

/*************************************
 * Heap Spraying WORKING 
 * Call heapVulnerability() in a way that does
 * not yield unexpected behavior
 ***********************************/
void heapWorking() {
    char input[4] = "Hi";
    int working_size = 4;
    cout << endl << "Heap Spraying: " << endl;
    cout << "The Heap Vulnerability is Working good 😂  😂  😂" << endl;
    heapVulnerability(input, working_size);
}

/*************************************
 * HEAP EXPLOIT
 * 1. The attacker must provide more data into the outwardly facing
 *    heap buffer than the buffer is designed to hold
 * 2. The attacker must know the layout of the Memory Control Block (MCB)
 *    (essentially a linked list) residing just after the buffer
 * 3. The attacker must provide a new MCB containing both the location
 *    of the memory overwrite and the new data to be overwritten
 ***********************************/
void heapExploit() {
  int size = 32;
  char input[32] = "pdfaobdnovbaowehfoiahoifhao";
  cout << "The Heap Exploit has been hacked 😩  😩  😩 " << endl << endl;
  heapVulnerability(input, size); 
}

 /*****************************************************************
* 7. ---------------------Integer Overflow-------------------------
 **************************************************************/

/********************************************
 * INTEGER VULNERABILITY
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel
 *    must be reachable through external input.
 *********************************************/
void intVulnerability(short a, string text) {
  long data[2];
  long * sentinel = data + 2;
  // try to protect
  if(sentinel > a + data) {
    // text = data[a];
    cout << "     Safe 😇  😇  😇" << endl;
  } else {
    cout << "     Dangerous 😡  😡  😡" << endl;
  }
}

/*************************************
 * INTEGER WORKING 
 * Call intVulnerability() in a way that does
 * not yield unexpected behavior
 ***********************************/
void intWorking() {
  // long w = 1;
  // intVulnerability(w);
  // 1 is okay, we can access, 15 not okay because overflowed
  int w1 = 1;
  int w2 = 15;
  string input1 = "We love our happy emojis so much";
  string input2 = "We hate our angry emojis very much";
  cout << endl << "Working Ingeter: " << endl;
  intVulnerability(w1, input1);
  intVulnerability(w2, input2);
}

/**********************************************
 * INTEGER EXPLOIT
 * 1. Provide input, either a buffer size or a single value,
 *    that is directly or indirectly used in the vulnerable expression
 * 2. The input must exceed the valid bounds of the data-type,
 *    resulting in an overflow or underflow condition
 **********************************************/
void intExploit() {
  // long exp = 67458764886;
  // intVulnerability(exp);
  // Max short 32767
  int exp = 32768;
  string input = "Exploit";
  cout << endl << "Exploiting Ingeter: " << endl;
  // char -127 -- 127 
  // Unassigned: 255
  intVulnerability(exp, input);
}

/*********************************************************
* 8. -------------ANSI-Unicode Conversion------------------
 ******************************************************************/

/*********************************************************
 * ANSI - UNICODE VULNERABILITY
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer
 *    rather than the number of elements in the buffer.
 ********************************************************/
void ansiVulnerability(const char * ansi, int size) 
{
  bool safe = true;
  short unicode[4];
  if (size <= sizeof(unicode)) 
  {
    for (int i = 0; i < size ; i++)
    {
    unicode[i] = (short)ansi[i];
    }
  }
  if (safe) {
    cout << endl << "ANSI Vulnerability: ";
    cout << endl << "ANSI Vulnerability Working: " << endl;
    std::cout << "     All is safe:nothing bad happened 🤩  🤩  🤩\n";
  } else {
    cout << "ANSI Vulnerability Exploitation: " << endl;
    std::cout << "     We've been hacked 😱  😱  😱 \n";
  }
}

/**************************************
 * ANSI WORKING
 * Call ansiVulnerability() in a way that does
 * not yield unexpected behavior
 *************************************/
void ansiWorking() {
  char input[4] = "hi";
  ansiVulnerability(input, sizeof(input));
}

/***********************************************
 * ASCI - UNICODE EXPLOIT
 * 1. The attacker must provide more than half as much data
 *    into the outwardly facing buffer as it is designed to hold
 * 2. From here, a variety of injection attacks are possible. 
 *    The most likely candidates are stack smashing or heap smashing. In the above   
 *    example, the third parameter of the copyUnicodeText() function is the number
 *    of elements in the string (256 elements), not the size of * the string 
 *    (512 bytes). The end result is a buffer overrun of 256 bytes.
 **********************************************/
void ansiExploit() {
  char input[6] = "ANSI";
  ansiVulnerability(input, sizeof(input));
}

/*************************************
* Main Function will call all functions
 ****************************************/
int main() {
  cout << "1. Array Index 😎" << endl;
  cout << "2. Pointer subterfuge 🤓" << endl;
  cout << "3. ARC Injection 🧐" << endl;
  cout << "4. VTable Spraying 🥵" << endl;
  cout << "5. Stack Smashing 🥶" << endl;
  cout << "6. Heap Spraying 😵" << endl;
  cout << "7. Integer Overflow 🤠" << endl;
  cout << "8. ANSI-Unicode Conversion 🤯 " << endl;
  int choose; // choosing the type of Vulnerability. 
  cout << "Choose one of the Vulnerability Above: 👉 ";
  cin >> choose;
  switch (choose) {
    case 1: 
      arrayWorking();
      arrayExploit();
      break;
    case 2: 
      psWorking();
      psExploit();
      break;
    case 3: 
      arcWorking();
      arcExploit();
      break;
    case 4: 
      vtableWorking();
      vtableExploit();
      break;
    case 5: 
      stackWorking();
      stackExploit();
      break;
    case 6:
      heapWorking();
      heapExploit();
      break;
    case 7:
      intWorking();
      intExploit();
      break;
    case 8:
      ansiWorking();
      ansiExploit();
      break;
    default:
      cout << "There is no option. Please, run the code again...😭 😭" << endl;
  }
  return 0;
}